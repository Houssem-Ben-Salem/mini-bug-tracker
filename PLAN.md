The goal is to build a professional-grade Mini Bug Tracker that satisfies all requirements, implements bonus features, and is built on a modern, persistent stack. The 12-hour timeline allows for proper data modeling, database integration, and component-based architecture.

**Target Stack:** **React (Functional Components/Hooks) \+ Tailwind CSS \+ Google Firestore** (for real-time persistence and multi-user readiness).

## **PHASE 1: ARCHITECTURE & DATA MODELING (Target: 1.5 Hours)**

**Objective:** Define the complete data structure, components, and persistence layer setup.

1. **Persistence Setup:**  
   * Initialize Firebase/Firestore connection using the provided global variables (`__app_id`, `__firebase_config`, `__initial_auth_token`).  
   * Implement immediate authentication (use `signInWithCustomToken` or `signInAnonymously`).  
   * Define the Firestore path for public data: `/artifacts/{__app_id}/public/data/issues`. All issues will be stored here.  
2. **Enhanced Data Model Definition (Issue Object Structure):** Define the JSON structure for an issue, incorporating all minimum and bonus features.

| Field Name | Data Type | Requirement / Notes |
| :---- | :---- | :---- |
| `id` | String | Document ID (auto-generated by Firestore). |
| `title` | String | Required. |
| `description` | String | Required (supports Markdown input for bonus points). |
| `status` | String | **Core Flow:** Must be one of: "Open", "In-Progress", "Review", "Closed". |
| `assignee` | String | String field (use the current `userId` by default). |
| `priority` | String | **Bonus 1:** Must be one of: "Critical", "High", "Medium", "Low". |
| `labels` | Array of Strings | **Bonus 2:** e.g., `["UI", "Backend", "Critical Bug"]`. |
| `comments` | Array of Objects | **Bonus 3:** Array of `{userId: string, text: string, timestamp: number}`. |
| `createdAt` | Firestore Timestamp | Auto-generated on creation. |
| `updatedAt` | Firestore Timestamp | Updated on every modification. |

3.   
   **Component Breakdown (High-Level):**  
   * `App`: Main container, handles Firebase initialization and state management (Issue list).  
   * `IssueList`: Displays filtered issues as cards.  
   * `IssueCard`: Displays title, status badge, priority, and quick action buttons.  
   * `FilterBar`: Input fields for search, status dropdown, priority dropdown.  
   * `IssueModal`: Single modal component for both Add and Edit functionality.  
   * `CommentSection`: Sub-component within the modal for viewing/adding comments.

## **PHASE 2: IMPLEMENTATION & PERSISTENCE (Target: 8.0 Hours)**

**Objective:** Build all components, integrate real-time data flow, and ensure persistence.

### **A. Data Flow & Real-Time Sync (2.0 Hours)**

1. **Initialization:** Set up the main `App` component to initialize Firebase and establish `onAuthStateChanged`.  
2. **Real-Time Collection:** Use the `useEffect` hook in `App` to set up an **`onSnapshot` listener** on the `/issues` collection. This must update the main issue state (`issues`) whenever data changes in the database.  
3. **CRUD Functions:** Create three asynchronous functions in `App` to handle Firestore interactions: `createIssue`, `updateIssue`, and `deleteIssue`.

### **B. Core Features & UI (4.0 Hours)**

1. **Layout & Responsiveness:** Build the main application shell using Tailwind CSS, ensuring a clean, fully mobile-responsive (mobile-first) two-column layout (Filters/List).  
2. **Filtering/Search:** Implement the `FilterBar` logic to filter the local `issues` state array based on **multiple simultaneous criteria**:  
   * Text search (in `title` and `description`).  
   * Exact match on `status`.  
   * Exact match on `priority`.  
3. **Issue Management:**  
   * Create the `IssueModal` with a controlled form that reflects the full data model (Title, Description, Assignee, Status, Priority, Labels).  
   * Implement dynamic handling to switch between **"Add New Issue"** and **"Edit Existing Issue"** modes using the same form/modal.  
   * **Status Toggling:** Implement quick-change buttons on the `IssueCard` to cycle the status (`Open` $\\rightarrow$ `In-Progress` $\\rightarrow$ `Review` $\\rightarrow$ `Closed`).

### **C. Bonus Features & Polish (2.0 Hours)**

1. **Priority Visualization:** Use dynamic Tailwind classes on the `IssueCard` to visually differentiate priority (e.g., `Critical` \= red badge, `Low` \= green badge).  
2. **Comment System:** In the `IssueModal`, display existing comments (sorted by timestamp) and provide a simple form to add a new comment object to the `comments` array field of the Firestore document.  
3. **Current User Display:** Display the current `userId` prominently on the screen (as required for multi-user apps).

## **PHASE 3: FINALIZATION & DOCUMENTATION (Target: 2.5 Hours)**

**Objective:** Final review, error handling, and creation of the required documentation.

1. **Product Quality Check:**  
   * Ensure all database operations include basic **error handling** (e.g., `try...catch` blocks that log errors to the console).  
   * Verify all UI elements (buttons, forms) have appropriate states (loading indicators, disabled state during database writes).  
   * Confirm the app is visually appealing and highly usable on a mobile screen.  
2. **README Generation:** Generate a comprehensive `README.md` file.  
   **README Content Requirements:**  
   * **Project Title:** Persistent Mini Bug Tracker (React/Firestore).  
   * **Technology Stack:** Explicitly list React, Tailwind CSS, and Firestore.  
   * **Installation/Execution:** Simple step-by-step instructions on how to save and run the single `.jsx` file and how to confirm the Firebase connection is active.  
   * **Feature List:** Detailed list of all implemented Core and Bonus features.  
   * **Creative Justification:** Explain that the 12-hour scope allowed for proper persistence (Firestore) and a professional component architecture (React) to meet the "Product Quality" and "Creativity" criteria.

**Output Requirement:** The AI must generate **ONE** complete, self-contained **React (`.jsx`)** file implementing the application logic and all components, followed by the complete `README.md` documentation file.

